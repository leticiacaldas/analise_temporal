import pandas as pd 
import warnings
import glob

# Imports condicionais para bibliotecas que podem n√£o estar dispon√≠veis
try:
    from sklearn.model_selection import train_test_split
    from sklearn.ensemble import RandomForestRegressor
    from sklearn.metrics import mean_squared_error
    SKLEARN_DISPONIVEL = True
except ImportError:
    SKLEARN_DISPONIVEL = False
    print("‚ö†Ô∏è Scikit-learn n√£o encontrado. Algumas funcionalidades ser√£o limitadas.")

try:
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    PLOTLY_DISPONIVEL = True
except ImportError:
    PLOTLY_DISPONIVEL = False
    print("‚ö†Ô∏è Plotly n√£o encontrado. Visualiza√ß√µes interativas ser√£o limitadas.")

# Importar visualiza√ß√µes matplotlib
try:
    from visualizacoes_matplotlib import criar_visualizacoes_completas
    MATPLOTLIB_DISPONIVEL = True
except ImportError:
    MATPLOTLIB_DISPONIVEL = False
    print("‚ö†Ô∏è M√≥dulo de visualiza√ß√µes matplotlib n√£o encontrado.")

warnings.filterwarnings("ignore")

class AnaliseMeteorolgicaRS:
    def __init__(self):
        self.dados_rio_grande = []
        self.dados_capao_leao = []
        self.dados_combinados = None
        self.colunas_mapeadas = {
            'Data': 'data',
            'Hora UTC': 'hora',
            'PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)': 'precipitacao',
            'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)': 'pressao',
            'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)': 'temperatura',
            'TEMPERATURA DO PONTO DE ORVALHO (¬∞C)': 'temp_orvalho',
            'UMIDADE RELATIVA DO AR, HORARIA (%)': 'umidade',
            'VENTO, VELOCIDADE HORARIA (m/s)': 'vento_velocidade',
            'VENTO, DIRE√á√ÉO HORARIA (gr) (¬∞ (gr))': 'vento_direcao',
            'RADIACAO GLOBAL (Kj/m¬≤)': 'radiacao'
        }
    
    def carregar_dados_multiplos_anos(self):
        """Carrega dados de todos os anos dispon√≠veis (2023, 2024, 2025)"""
        anos = ['2023', '2024', '2025']
        
        for ano in anos:
            # Rio Grande
            arquivo_rg = f"{ano}/INMET_S_RS_A802_RIO GRANDE_01-01-{ano}_A_*.CSV"
            arquivos_rg = glob.glob(arquivo_rg)
            
            if arquivos_rg:
                df_rg = self._processar_arquivo(arquivos_rg[0])
                if df_rg is not None:
                    df_rg['cidade'] = 'Rio Grande'
                    df_rg['ano'] = int(ano)
                    self.dados_rio_grande.append(df_rg)
            
            # Cap√£o do Le√£o
            arquivo_cl = f"{ano}/INMET_S_RS_A887_CAPAO DO LEAO (PELOTAS)_01-01-{ano}_A_*.CSV"
            arquivos_cl = glob.glob(arquivo_cl)
            
            if arquivos_cl:
                df_cl = self._processar_arquivo(arquivos_cl[0])
                if df_cl is not None:
                    df_cl['cidade'] = 'Cap√£o do Le√£o'
                    df_cl['ano'] = int(ano)
                    self.dados_capao_leao.append(df_cl)
        
        # Combinar todos os dados
        self._combinar_dados()
        print("‚úÖ Dados carregados com sucesso!")
        print(f"   üìä Rio Grande: {len(self.dados_rio_grande)} arquivos")
        print(f"   üìä Cap√£o do Le√£o: {len(self.dados_capao_leao)} arquivos")
    
    def _processar_arquivo(self, arquivo):
        """Processa um arquivo CSV individual"""
        try:
            # Ler arquivo pulando as linhas de metadados
            df = pd.read_csv(arquivo, sep=';', skiprows=8, encoding='latin-1')
            
            # Limpar nomes das colunas
            df.columns = df.columns.str.strip()
            
            # Criar datetime combinando data e hora
            df['datetime'] = pd.to_datetime(df['Data'] + ' ' + df['Hora UTC'], 
                                         format='%Y/%m/%d %H%M UTC', errors='coerce')
            
            # Selecionar e renomear colunas importantes
            colunas_importantes = [
                'Data', 'Hora UTC', 'PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)',
                'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)',
                'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)',
                'TEMPERATURA DO PONTO DE ORVALHO (¬∞C)',
                'UMIDADE RELATIVA DO AR, HORARIA (%)',
                'VENTO, VELOCIDADE HORARIA (m/s)',
                'VENTO, DIRE√á√ÉO HORARIA (gr) (¬∞ (gr))',
                'RADIACAO GLOBAL (Kj/m¬≤)'
            ]
            
            # Verificar quais colunas existem
            colunas_existentes = [col for col in colunas_importantes if col in df.columns]
            df_processado = df[['datetime'] + colunas_existentes].copy()
            
            # Converter colunas num√©ricas
            for col in colunas_existentes:
                if col not in ['Data', 'Hora UTC']:
                    df_processado[col] = pd.to_numeric(df_processado[col], errors='coerce')
            
            # Remover linhas com datetime inv√°lido
            df_processado = df_processado.dropna(subset=['datetime'])
            
            return df_processado
            
        except (FileNotFoundError, pd.errors.EmptyDataError, ValueError) as e:
            print(f"Erro ao processar arquivo {arquivo}: {e}")
            return None
    
    def _combinar_dados(self):
        """Combina todos os dados em um √∫nico DataFrame"""
        if self.dados_rio_grande and self.dados_capao_leao:
            # Concatenar dados de Rio Grande
            df_rg_completo = pd.concat(self.dados_rio_grande, ignore_index=True)
            
            # Concatenar dados de Cap√£o do Le√£o
            df_cl_completo = pd.concat(self.dados_capao_leao, ignore_index=True)
            
            # Combinar ambas as cidades
            self.dados_combinados = pd.concat([df_rg_completo, df_cl_completo], ignore_index=True)
            
            # Ordenar por datetime
            self.dados_combinados = self.dados_combinados.sort_values('datetime').reset_index(drop=True)
    
    def estatisticas_descritivas(self):
        """Gera estat√≠sticas descritivas completas"""
        if self.dados_combinados is None:
            print("‚ùå Dados n√£o carregados. Execute carregar_dados_multiplos_anos() primeiro.")
            return
        
        print("=" * 60)
        print("üìä ESTAT√çSTICAS DESCRITIVAS METEOROL√ìGICAS")
        print("=" * 60)
        
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_cidade = self.dados_combinados[self.dados_combinados['cidade'] == cidade]
            
            print(f"\nüèôÔ∏è  {cidade.upper()}")
            print("-" * 40)
            
            # Temperatura
            if 'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)' in dados_cidade.columns:
                temp = dados_cidade['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)'].dropna()
                print("üå°Ô∏è  Temperatura:")
                print(f"   M√©dia: {temp.mean():.1f}¬∞C")
                print(f"   M√°xima: {temp.max():.1f}¬∞C")
                print(f"   M√≠nima: {temp.min():.1f}¬∞C")
                print(f"   Desvio Padr√£o: {temp.std():.1f}¬∞C")
            
            # Precipita√ß√£o
            if 'PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)' in dados_cidade.columns:
                precip = dados_cidade['PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)'].dropna()
                print("üåßÔ∏è  Precipita√ß√£o:")
                print(f"   Total: {precip.sum():.1f}mm")
                print(f"   M√©dia hor√°ria: {precip.mean():.2f}mm")
                print(f"   M√°xima hor√°ria: {precip.max():.1f}mm")
            
            # Umidade
            if 'UMIDADE RELATIVA DO AR, HORARIA (%)' in dados_cidade.columns:
                umid = dados_cidade['UMIDADE RELATIVA DO AR, HORARIA (%)'].dropna()
                print("üíß Umidade:")
                print(f"   M√©dia: {umid.mean():.1f}%")
                print(f"   M√°xima: {umid.max():.1f}%")
                print(f"   M√≠nima: {umid.min():.1f}%")
            
            # Vento
            if 'VENTO, VELOCIDADE HORARIA (m/s)' in dados_cidade.columns:
                vento = dados_cidade['VENTO, VELOCIDADE HORARIA (m/s)'].dropna()
                print("üí® Vento:")
                print(f"   Velocidade m√©dia: {vento.mean():.1f}m/s")
                print(f"   Rajada m√°xima: {vento.max():.1f}m/s")
    
    def comparacao_cidades(self):
        """Compara estatisticamente as duas cidades"""
        if self.dados_combinados is None:
            print("‚ùå Dados n√£o carregados.")
            return
        
        print("\n" + "=" * 60)
        print("üîÑ COMPARA√á√ÉO ESTAT√çSTICA ENTRE CIDADES")
        print("=" * 60)
        
        # Preparar dados para compara√ß√£o
        rg_data = self.dados_combinados[self.dados_combinados['cidade'] == 'Rio Grande']
        cl_data = self.dados_combinados[self.dados_combinados['cidade'] == 'Cap√£o do Le√£o']
        
        variaveis = [
            ('TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)', 'üå°Ô∏è Temperatura'),
            ('PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)', 'üåßÔ∏è Precipita√ß√£o'),
            ('UMIDADE RELATIVA DO AR, HORARIA (%)', 'üíß Umidade'),
            ('VENTO, VELOCIDADE HORARIA (m/s)', 'üí® Velocidade do Vento'),
            ('PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)', 'üìä Press√£o')
        ]
        
        for var_col, var_nome in variaveis:
            if var_col in self.dados_combinados.columns:
                rg_var = rg_data[var_col].dropna()
                cl_var = cl_data[var_col].dropna()
                
                if len(rg_var) > 0 and len(cl_var) > 0:
                    print(f"\n{var_nome}:")
                    print(f"   Rio Grande - M√©dia: {rg_var.mean():.2f}")
                    print(f"   Cap√£o do Le√£o - M√©dia: {cl_var.mean():.2f}")
                    print(f"   Diferen√ßa: {rg_var.mean() - cl_var.mean():.2f}")
                    print(f"   Rio Grande - Desvio Padr√£o: {rg_var.std():.2f}")
                    print(f"   Cap√£o do Le√£o - Desvio Padr√£o: {cl_var.std():.2f}")
                    
                    # An√°lise simples de diferen√ßa percentual
                    diff_percentual = abs(rg_var.mean() - cl_var.mean()) / ((rg_var.mean() + cl_var.mean()) / 2) * 100
                    if diff_percentual > 5:
                        print(f"   üìä Diferen√ßa consider√°vel ({diff_percentual:.1f}%)")
                    else:
                        print(f"   üìä Diferen√ßa pequena ({diff_percentual:.1f}%)")
    
    def visualizacoes_comparativas_avancadas(self):
        """Cria visualiza√ß√µes comparativas avan√ßadas"""
        if self.dados_combinados is None:
            print("‚ùå Dados n√£o carregados.")
            return
        
        if not PLOTLY_DISPONIVEL:
            print("‚ùå Plotly n√£o dispon√≠vel. Visualiza√ß√µes interativas n√£o podem ser criadas.")
            return
        
        # Criar m√∫ltiplos gr√°ficos
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=[
                'Temperatura por Cidade', 'Precipita√ß√£o por Cidade',
                'Umidade vs Temperatura', 'Distribui√ß√£o de Temperaturas',
                'Velocidade do Vento', 'Press√£o Atmosf√©rica'
            ],
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        # Preparar dados mensais
        dados_mensais = self._preparar_dados_mensais()
        
        cores = {'Rio Grande': '#1f77b4', 'Cap√£o do Le√£o': '#ff7f0e'}
        
        # 1. Temperatura por cidade (s√©rie temporal)
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_cidade = dados_mensais[dados_mensais['cidade'] == cidade]
            fig.add_trace(
                go.Scatter(
                    x=dados_cidade['data_mes'],
                    y=dados_cidade['temp_media'],
                    mode='lines+markers',
                    name=f'{cidade} - Temp',
                    line=dict(color=cores[cidade]),
                    showlegend=True
                ),
                row=1, col=1
            )
        
        # 2. Precipita√ß√£o acumulada
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_cidade = dados_mensais[dados_mensais['cidade'] == cidade]
            fig.add_trace(
                go.Bar(
                    x=dados_cidade['data_mes'],
                    y=dados_cidade['precip_total'],
                    name=f'{cidade} - Precip',
                    marker_color=cores[cidade],
                    opacity=0.7,
                    showlegend=False
                ),
                row=1, col=2
            )
        
        # 3. Scatter: Umidade vs Temperatura
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_scatter = self.dados_combinados[
                (self.dados_combinados['cidade'] == cidade) &
                (self.dados_combinados['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)'].notna()) &
                (self.dados_combinados['UMIDADE RELATIVA DO AR, HORARIA (%)'].notna())
            ].sample(n=min(1000, len(self.dados_combinados[self.dados_combinados['cidade'] == cidade])))
            
            fig.add_trace(
                go.Scatter(
                    x=dados_scatter['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)'],
                    y=dados_scatter['UMIDADE RELATIVA DO AR, HORARIA (%)'],
                    mode='markers',
                    name=f'{cidade}',
                    marker=dict(color=cores[cidade], size=4, opacity=0.6),
                    showlegend=False
                ),
                row=2, col=1
            )
        
        # 4. Histograma de temperaturas
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_temp = self.dados_combinados[
                (self.dados_combinados['cidade'] == cidade) &
                (self.dados_combinados['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)'].notna())
            ]['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)']
            
            fig.add_trace(
                go.Histogram(
                    x=dados_temp,
                    name=f'{cidade}',
                    opacity=0.7,
                    marker_color=cores[cidade],
                    showlegend=False,
                    nbinsx=30
                ),
                row=2, col=2
            )
        
        # 5. Velocidade do vento
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_cidade = dados_mensais[dados_mensais['cidade'] == cidade]
            fig.add_trace(
                go.Scatter(
                    x=dados_cidade['data_mes'],
                    y=dados_cidade['vento_medio'],
                    mode='lines+markers',
                    name=f'{cidade} - Vento',
                    line=dict(color=cores[cidade]),
                    showlegend=False
                ),
                row=3, col=1
            )
        
        # 6. Press√£o atmosf√©rica
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            dados_cidade = dados_mensais[dados_mensais['cidade'] == cidade]
            fig.add_trace(
                go.Scatter(
                    x=dados_cidade['data_mes'],
                    y=dados_cidade['pressao_media'],
                    mode='lines+markers',
                    name=f'{cidade} - Press√£o',
                    line=dict(color=cores[cidade]),
                    showlegend=False
                ),
                row=3, col=2
            )
        
        # Atualizar layout
        fig.update_layout(
            height=1200,
            title_text="üìä An√°lise Meteorol√≥gica Comparativa: Rio Grande vs Cap√£o do Le√£o",
            showlegend=True,
            title_font_size=16
        )
        
        # Atualizar eixos
        fig.update_xaxes(title_text="Data", row=1, col=1)
        fig.update_yaxes(title_text="Temperatura (¬∞C)", row=1, col=1)
        
        fig.update_xaxes(title_text="Data", row=1, col=2)
        fig.update_yaxes(title_text="Precipita√ß√£o (mm)", row=1, col=2)
        
        fig.update_xaxes(title_text="Temperatura (¬∞C)", row=2, col=1)
        fig.update_yaxes(title_text="Umidade (%)", row=2, col=1)
        
        fig.update_xaxes(title_text="Temperatura (¬∞C)", row=2, col=2)
        fig.update_yaxes(title_text="Frequ√™ncia", row=2, col=2)
        
        fig.update_xaxes(title_text="Data", row=3, col=1)
        fig.update_yaxes(title_text="Velocidade (m/s)", row=3, col=1)
        
        fig.update_xaxes(title_text="Data", row=3, col=2)
        fig.update_yaxes(title_text="Press√£o (mB)", row=3, col=2)
        
        fig.show()
    
    def _preparar_dados_mensais(self):
        """Prepara dados agregados mensalmente"""
        if self.dados_combinados is None:
            return pd.DataFrame()
        
        # Adicionar colunas de data
        self.dados_combinados['ano_mes'] = self.dados_combinados['datetime'].dt.to_period('M')
        
        # Agregar por m√™s e cidade
        dados_mensais = self.dados_combinados.groupby(['cidade', 'ano_mes']).agg({
            'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)': ['mean', 'max', 'min'],
            'PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)': 'sum',
            'UMIDADE RELATIVA DO AR, HORARIA (%)': 'mean',
            'VENTO, VELOCIDADE HORARIA (m/s)': 'mean',
            'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)': 'mean'
        }).reset_index()
        
        # Renomear colunas
        dados_mensais.columns = [
            'cidade', 'ano_mes', 'temp_media', 'temp_max', 'temp_min',
            'precip_total', 'umidade_media', 'vento_medio', 'pressao_media'
        ]
        
        # Converter per√≠odo para datetime
        dados_mensais['data_mes'] = dados_mensais['ano_mes'].dt.to_timestamp()
        
        return dados_mensais
    
    def analise_sazonalidade(self):
        """Analisa padr√µes sazonais"""
        if self.dados_combinados is None:
            print("‚ùå Dados n√£o carregados.")
            return
        
        print("\n" + "=" * 60)
        print("üåø AN√ÅLISE DE SAZONALIDADE")
        print("=" * 60)
        
        # Adicionar informa√ß√µes de esta√ß√£o
        self.dados_combinados['mes'] = self.dados_combinados['datetime'].dt.month
        
        def definir_estacao(mes):
            if mes in [12, 1, 2]:
                return 'Ver√£o'
            elif mes in [3, 4, 5]:
                return 'Outono'
            elif mes in [6, 7, 8]:
                return 'Inverno'
            else:
                return 'Primavera'
        
        self.dados_combinados['estacao'] = self.dados_combinados['mes'].apply(definir_estacao)
        
        # An√°lise por esta√ß√£o
        for cidade in ['Rio Grande', 'Cap√£o do Le√£o']:
            print(f"\nüèôÔ∏è {cidade}:")
            dados_cidade = self.dados_combinados[self.dados_combinados['cidade'] == cidade]
            
            estacoes_stats = dados_cidade.groupby('estacao').agg({
                'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)': 'mean',
                'PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)': 'sum',
                'UMIDADE RELATIVA DO AR, HORARIA (%)': 'mean'
            }).round(2)
            
            print(estacoes_stats)
    
    def modelo_previsao_temperatura(self):
        """Cria modelo de previs√£o de temperatura"""
        if self.dados_combinados is None:
            print("‚ùå Dados n√£o carregados.")
            return
        
        if not SKLEARN_DISPONIVEL:
            print("‚ùå Scikit-learn n√£o dispon√≠vel. Modelo de previs√£o n√£o pode ser criado.")
            return
        
        print("\n" + "=" * 60)
        print("ü§ñ MODELO DE PREVIS√ÉO DE TEMPERATURA")
        print("=" * 60)
        
        # Preparar dados para modelagem
        dados_modelo = self.dados_combinados.dropna(subset=[
            'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)',
            'UMIDADE RELATIVA DO AR, HORARIA (%)',
            'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)',
            'VENTO, VELOCIDADE HORARIA (m/s)'
        ]).copy()
        
        # Features
        features = [
            'UMIDADE RELATIVA DO AR, HORARIA (%)',
            'PRESSAO ATMOSFERICA AO NIVEL DA ESTACAO, HORARIA (mB)',
            'VENTO, VELOCIDADE HORARIA (m/s)'
        ]
        
        # Adicionar features temporais
        dados_modelo['hora'] = dados_modelo['datetime'].dt.hour
        dados_modelo['dia_ano'] = dados_modelo['datetime'].dt.dayofyear
        dados_modelo['mes'] = dados_modelo['datetime'].dt.month
        features.extend(['hora', 'dia_ano', 'mes'])
        
        # Encoding para cidade
        dados_modelo['cidade_encoded'] = dados_modelo['cidade'].map({'Rio Grande': 0, 'Cap√£o do Le√£o': 1})
        features.append('cidade_encoded')
        
        X = dados_modelo[features]
        y = dados_modelo['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)']
        
        # Dividir dados
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Treinar modelo
        rf_modelo = RandomForestRegressor(n_estimators=100, random_state=42)
        rf_modelo.fit(X_train, y_train)
        
        # Previs√µes
        y_pred = rf_modelo.predict(X_test)
        
        # M√©tricas
        mse = mean_squared_error(y_test, y_pred)
        rmse = mse ** 0.5  # Calcular raiz quadrada de forma mais robusta
        
        print("üìä M√©tricas do Modelo:")
        print(f"   RMSE: {rmse:.2f}¬∞C")
        print(f"   R¬≤: {rf_modelo.score(X_test, y_test):.3f}")
        
        # Import√¢ncia das features
        importancias = pd.DataFrame({
            'feature': features,
            'importancia': rf_modelo.feature_importances_
        }).sort_values('importancia', ascending=False)
        
        print("\nüéØ Import√¢ncia das Vari√°veis:")
        for _, row in importancias.iterrows():
            print(f"   {row['feature']}: {row['importancia']:.3f}")
        
        return rf_modelo
    
    def relatorio_completo(self):
        """Gera relat√≥rio completo da an√°lise"""
        print("üöÄ Executando An√°lise Meteorol√≥gica Completa...")
        print("=" * 60)
        
        # Carregar dados
        self.carregar_dados_multiplos_anos()
        
        # Estat√≠sticas
        self.estatisticas_descritivas()
        
        # Compara√ß√£o
        self.comparacao_cidades()
        
        # Sazonalidade
        self.analise_sazonalidade()
        
        # Visualiza√ß√µes Plotly
        if PLOTLY_DISPONIVEL:
            print("\nüéØ Criando visualiza√ß√µes interativas (Plotly)...")
            self.visualizacoes_comparativas_avancadas()
        else:
            print("\n‚ö†Ô∏è Visualiza√ß√µes Plotly n√£o dispon√≠veis (biblioteca n√£o encontrada)")
        
        # Modelo
        if SKLEARN_DISPONIVEL:
            print("\nü§ñ Criando modelo de previs√£o...")
            modelo_resultado = self.modelo_previsao_temperatura()
        else:
            print("\n‚ö†Ô∏è Modelo de previs√£o n√£o dispon√≠vel (Scikit-learn n√£o encontrado)")
            modelo_resultado = None
        
        # Visualiza√ß√µes matplotlib
        if MATPLOTLIB_DISPONIVEL and self.dados_combinados is not None:
            print("\nüé® Criando visualiza√ß√µes est√°ticas (Matplotlib)...")
            try:
                criar_visualizacoes_completas(self.dados_combinados)
            except (ImportError, AttributeError) as e:
                print(f"‚ö†Ô∏è Erro nas visualiza√ß√µes matplotlib: {e}")
        
        # Insights finais
        self.gerar_insights_finais()
        
        print("\n" + "=" * 60)
        print("‚úÖ AN√ÅLISE CONCLU√çDA COM SUCESSO!")
        print("=" * 60)
        
        return modelo_resultado
    
    def gerar_insights_finais(self):
        """Gera insights finais da an√°lise"""
        if self.dados_combinados is None:
            return
        
        print("\n" + "=" * 60)
        print("üîç INSIGHTS PRINCIPAIS")
        print("=" * 60)
        
        # Calcular diferen√ßas m√©dias
        rg_data = self.dados_combinados[self.dados_combinados['cidade'] == 'Rio Grande']
        cl_data = self.dados_combinados[self.dados_combinados['cidade'] == 'Cap√£o do Le√£o']
        
        # Temperatura
        if 'TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)' in self.dados_combinados.columns:
            temp_rg = rg_data['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)'].mean()
            temp_cl = cl_data['TEMPERATURA DO AR - BULBO SECO, HORARIA (¬∞C)'].mean()
            
            if temp_rg > temp_cl:
                print(f"üå°Ô∏è Rio Grande √© em m√©dia {temp_rg - temp_cl:.1f}¬∞C mais quente que Cap√£o do Le√£o")
            else:
                print(f"üå°Ô∏è Cap√£o do Le√£o √© em m√©dia {temp_cl - temp_rg:.1f}¬∞C mais quente que Rio Grande")
        
        # Precipita√ß√£o
        if 'PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)' in self.dados_combinados.columns:
            precip_rg = rg_data['PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)'].sum()
            precip_cl = cl_data['PRECIPITA√á√ÉO TOTAL, HOR√ÅRIO (mm)'].sum()
            
            if precip_rg > precip_cl:
                print(f"üåßÔ∏è Rio Grande teve {precip_rg - precip_cl:.0f}mm a mais de chuva no per√≠odo")
            else:
                print(f"üåßÔ∏è Cap√£o do Le√£o teve {precip_cl - precip_rg:.0f}mm a mais de chuva no per√≠odo")
        
        # Umidade
        if 'UMIDADE RELATIVA DO AR, HORARIA (%)' in self.dados_combinados.columns:
            umid_rg = rg_data['UMIDADE RELATIVA DO AR, HORARIA (%)'].mean()
            umid_cl = cl_data['UMIDADE RELATIVA DO AR, HORARIA (%)'].mean()
            
            if umid_rg > umid_cl:
                print(f"üíß Rio Grande √© {umid_rg - umid_cl:.1f}% mais √∫mido em m√©dia")
            else:
                print(f"üíß Cap√£o do Le√£o √© {umid_cl - umid_rg:.1f}% mais √∫mido em m√©dia")
        
        # Vento
        if 'VENTO, VELOCIDADE HORARIA (m/s)' in self.dados_combinados.columns:
            vento_rg = rg_data['VENTO, VELOCIDADE HORARIA (m/s)'].mean()
            vento_cl = cl_data['VENTO, VELOCIDADE HORARIA (m/s)'].mean()
            
            if vento_rg > vento_cl:
                print(f"üí® Rio Grande tem ventos {vento_rg - vento_cl:.1f}m/s mais fortes em m√©dia")
            else:
                print(f"üí® Cap√£o do Le√£o tem ventos {vento_cl - vento_rg:.1f}m/s mais fortes em m√©dia")
        
        print("\nüìã Recomenda√ß√µes:")
        print("   ‚Ä¢ Use os modelos de previs√£o para planejamento agr√≠cola")
        print("   ‚Ä¢ Monitore padr√µes sazonais para atividades ao ar livre")
        print("   ‚Ä¢ Considere as diferen√ßas clim√°ticas para cultivos espec√≠ficos")
        print("   ‚Ä¢ Utilize os gr√°ficos para comunicar resultados a stakeholders")


# Executar an√°lise completa
if __name__ == "__main__":
    analise = AnaliseMeteorolgicaRS()
    modelo = analise.relatorio_completo()